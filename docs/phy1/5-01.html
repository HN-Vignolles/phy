<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">-->
    <title>Phy1</title>
    <style>
        [v-cloak] {
            display: none;
        }
        body {
            background-color: black;
        }
        .flex-container {
            display: flex;
            flex-wrap: wrap;
        }
        .flex-item-left {
            flex: 70%;
        }
        .flex-item-right {
            flex: 20%
        }
        @media (max-width: 800px) {
            .flex-item-left, .flex-item-right {
                flex: 100%;
            }
        }
        .stats {
            color: lightgray;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="flex-container">
            <div class="flex-item-left">
                <canvas id="c" width="800px" height="500px"></canvas>
            </div>
            <div class="flex-item-right">
                <div id="gui_container" class="gui_fix"></div>
            </div>
        </div>
        <div class="stats" id="data">data</div>
        <div id="plot">plot</div>
    </div>
    <!-- Vue3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Three.js + dat.GUI -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@v0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@v0.157.0/examples/jsm/",
                "dat.gui": "https://unpkg.com/dat.gui@0.7.7/build/dat.gui.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { GUI } from 'dat.gui'

        // canvas, renderer, camera and scene
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas }); //const renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 2, 6);
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.intensity = 0.08;
        scene.add(ambientLight);

        // spotlight
        const spotLight = new THREE.SpotLight(0xffffff, 20);
        spotLight.angle = Math.PI/5;
        spotLight.position.set(2.7, 4, 2);
        spotLight.castShadow = true;
        spotLight.shadow.camera.near = 1;
        spotLight.shadow.camera.far = 100;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        scene.add(spotLight);

        // floor
        const floorG = new THREE.PlaneGeometry(20, 20, 1, 1);
        const floorM = new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: true });
        const floor = new THREE.Mesh(floorG, floorM);
        floor.material.side = THREE.DoubleSide;
        floor.rotation.x = -Math.PI/2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Check if the renderer's canvas is not already the size it is being displayed as, and if so, set its size.
        // (probably from threejs.org)
        function resizeRendererToDisplaySize(renderer) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if(needResize){
                if(width < 800){
                renderer.setSize(width - 50, height - 50, false); // canvas's drawingbuffer size (internal size)
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                } else {
                    renderer.setSize(800, 500, false);
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }
            }
            return needResize;
        }

        // GLB
        // https://discourse.threejs.org/t/most-simple-way-to-wait-loading-in-gltf-loader/13896/4
        const loader = new GLTFLoader();
        function modelLoader(url){
            return new Promise((resolve, reject) => {
                loader.load(url, data => resolve(data), null, reject);
            });
        }
        let cylinder;
        let sphereInit;
        async function addModel(){
            const gltf = await modelLoader('./cylinder.glb');
            cylinder = gltf.scene;
            gltf.scene.traverse((node) => {
                if(node.isMesh){
                    if(node.name === 'Sphere'){
                        sphereInit = node;
                    }
                    //https://discourse.threejs.org/t/three-js-no-shadow/14532/13
                    node.castShadow = true;
                    //node.receiveShadow = true;
                }
            });
            scene.add(cylinder);
        }
        await addModel();
        const pointA = sphereInit.getWorldPosition(new THREE.Vector3())
        //cylinder.position.y = 2;
        cylinder.rotation.x = Math.PI/2;

        // Orbit Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window);
        //controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 1;
        controls.maxDistance = 10;
        controls.maxPolarAngle = Math.PI / 2;

        // dat.GUI
        const gui = new GUI({ autoPlace: false });
        gui.domElement.id = 'gui';
        gui_container.appendChild(gui.domElement);
        const cameraFolder = gui.addFolder('Camera');
        cameraFolder.add(camera.position, 'x', -10, 10).listen();
        cameraFolder.add(camera.position, 'y', -10, 10).listen();
        cameraFolder.add(camera.position, 'z', 0, 10).listen();
        cameraFolder.open();

        const lightFolder = gui.addFolder('Light');
        lightFolder.add(spotLight, 'angle', 0, Math.PI).listen();
        lightFolder.add(spotLight.shadow.camera, 'near', 0, 2).listen();
        lightFolder.add(spotLight.shadow.camera, 'far', 0, 100).listen();
        lightFolder.add(spotLight.position, 'x', -10, 10).listen();
        lightFolder.add(spotLight.position, 'y', -10, 10).listen();
        lightFolder.add(spotLight.position, 'z', 0, 10).listen();
        lightFolder.open();

        const cylinderFolder = gui.addFolder('Cylinder');
        cylinderFolder.add(cylinder.position, 'x', 0, 10).name('pos x').listen();
        cylinderFolder.add(cylinder.position, 'y', 0, 10).name('pos y').listen();
        cylinderFolder.add(cylinder.position, 'z', 0, 10).name('pos z').listen();
        cylinderFolder.open();

        const arrowOrigin = new THREE.Vector3();
        const arrowLength = 1;
        const arrowColor = 0xff0000;
        const arrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), arrowOrigin, arrowLength, arrowColor);
        scene.add(arrow);

        const offsetA = new THREE.Vector3(0, 0, 0);
        const pointFolder = gui.addFolder('Point A');
        pointFolder.add(offsetA, 'x', -2, 2, 0.1).name('x offset').listen();
        pointFolder.add(offsetA, 'y', -2, 2, 0.1).name('y offset').listen();
        pointFolder.add(offsetA, 'z', -2, 2, 0.1).name('z offset').listen();
        pointFolder.open();

        const objFolder = gui.addFolder('Misc');
        const obj = { y_val: 10 };
        objFolder.domElement.style.pointerEvents = "none"
        objFolder.add(obj, 'y_val').listen();
        objFolder.open();
        
        const dataDiv = document.querySelector('#data');
        const animate = () => {
            // set the aspect of the camera to the aspect of the canvas's display size:
            resizeRendererToDisplaySize(renderer);

            //const rotatedPointA = pointA.clone().applyEuler(cylinder.rotation);
            // Under the hood, Three.js uses quaternions to represent rotations.
            // Quaternions are a mathematical representation of 3D rotations that avoid
            // some of the limitations and issues associated with Euler angles, such as gimbal lock.

            const A3 = new THREE.Vector3();
            sphereInit.getWorldPosition(A3);

            const hatT_ = new THREE.Vector3(1, 0, 0);
            const hatT = hatT_.clone().applyEuler(cylinder.rotation);

            const tA = new THREE.Vector3();
            tA.addVectors(pointA, offsetA);
            const rotatedPointA = tA.clone().applyEuler(cylinder.rotation);
            arrow.position.set(...rotatedPointA);
            //arrow.setDirection(new THREE.Vector3(1,1,0))
            arrow.setDirection(hatT);

            dataDiv.innerHTML =  `Point A: x = ${rotatedPointA.x.toFixed(3)}, y = ${rotatedPointA.y.toFixed(3)}, z = ${rotatedPointA.z.toFixed(3)}<br/>`;
            dataDiv.innerHTML += `Sphere:&nbsp; x = ${A3.x.toFixed(3)}, y = ${A3.y.toFixed(3)}, z = ${A3.z.toFixed(3)}`;
            // Rotate the cylinder about the axis with the least moment of inertia (e.g., Y-axis).
            cylinder.rotation.y += 0.01; // Adjust the rotation speed as needed.

            controls.update();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>